import fs from "node:fs";
import path from "node:path";
import { glob } from "glob";
import { resolveNextIntlYamlOptions } from "./options";
import type { NextIntlYamlOptions } from "./types";

/**
 * Converts dashed text into PascalCase for next-intl namespaces.
 * @param value - Dashed text
 * @returns PascalCase namespace
 */
function toPascalCase(value: string): string {
  return value
    .split("-")
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join("");
}

/**
 * Generates a static YAML import manifest consumed by next-intl request config.
 * @param options - next-intl-yaml options
 */
export function generateLocalesManifest(options?: NextIntlYamlOptions): void {
  try {
    const resolved = resolveNextIntlYamlOptions(options);
    const outputPath = path.resolve(resolved.manifestOutputPath);
    const outputDirectory = path.dirname(outputPath);
    const yamlFiles = glob.sync(resolved.globSource).sort();
    const projectRoot = process.cwd();
    const imports: string[] = [];
    const entriesByLocale: Record<string, string[]> = {};
    let importIndex = 0;

    for (const filePath of yamlFiles) {
      const absoluteFilePath = path.resolve(filePath);
      const relativeImportPath = path
        .relative(outputDirectory, absoluteFilePath)
        .replaceAll(path.sep, "/");
      const importPath = relativeImportPath.startsWith(".")
        ? relativeImportPath
        : `./${relativeImportPath}`;
      const aliasedImportPath = resolved.relativeImportPathAlias
        ? `${resolved.relativeImportPathAlias.replace(/\/+$/, "")}/${path
            .relative(projectRoot, absoluteFilePath)
            .replaceAll(path.sep, "/")
            .replace(/^src\//, "")}`
        : importPath;
      const importVariable = `m${importIndex}`;
      const fileName = path.basename(filePath, ".yaml");
      const [blockName, locale] = fileName.split(".");

      if (!blockName || !locale) {
        continue;
      }

      const namespace = toPascalCase(blockName);
      imports.push(
        `import ${importVariable} from ${JSON.stringify(aliasedImportPath)};`,
      );

      entriesByLocale[locale] ??= [];
      entriesByLocale[locale].push(
        `    ${JSON.stringify(namespace)}: ${importVariable},`,
      );
      importIndex += 1;
    }

    const locales = Object.keys(entriesByLocale).sort();
    const localeBlocks = locales.map((locale) => {
      const entries = entriesByLocale[locale];
      return `  ${JSON.stringify(locale)}: {\n${entries.join("\n")}\n  },`;
    });

    const fileContent = `/* eslint-disable */
// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
// Generated by next-intl-yaml.

${imports.join("\n")}

export const localeYamlMessages = {
${localeBlocks.join("\n")}
} as Record<string, Record<string, Record<string, unknown>>>;
`;

    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, `${fileContent}\n\n`, "utf-8");
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(
      `[next-intl-yaml] Failed to generate locales manifest: ${message}`,
    );
  }
}
